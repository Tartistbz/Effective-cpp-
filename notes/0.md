# 术语（Terminology）
## 声明式(declaration)
**告诉编译器某个东西的名称和类型**
```cpp
extern int x; //对象(Object)声明式
std::size_t numDigits(int number);//函数(function)声明式
class Widget;  //类（class）声明式
template<typename T> //模板(template)声明式
```
### devlaration的意义
- 实现模块化分离
声明式通常用于头文件中，目的是实现代码的模块化和分离。通过声明符号，头文件可以在多个源文件之间共享而不暴露具体实现。这样做可以提高代码的可维护性和复用性。
``` cpp
// header.h
extern int add(int a, int b);  // 声明函数add

// source.cpp
#include "header.h"
int add(int a, int b) { return a + b; }  // 定义函数add
```
- 避免重复定义
在大规模项目中，如果每个源文件都直接定义相同的符号（比如全局变量、函数等），就会导致重复定义错误。通过声明，多个源文件可以共享同一个符号的定义，而不会重复定义它。
```cpp
// file1.cpp
extern int x;  // 声明x
int x = 10;    // 定义x

// file2.cpp
extern int x;  // 仅声明，不定义
```
- 支持链接
在C++中，声明式和定义式的分离为链接提供了支持。在多文件项目中，声明用于在多个源文件之间“沟通”符号，而定义则将符号的内存分配给它们。编译器编译时通过声明了解符号类型，链接器在链接阶段将这些符号关联起来。
```cpp
// file1.cpp
int x = 5;  // 定义

// file2.cpp
extern int x;  // 声明
```
- 实现抽象
声明式常常用于定义接口，即对外公开的API。接口声明只暴露函数的原型，而具体的实现细节隐藏在源文件中。这样，其他模块可以通过声明来与该模块交互，而不需要关心具体的实现细节。
```cpp
// interface.h
void doSomething();  // 声明

// implementation.cpp
#include "interface.h"
void doSomething() { /* 实现细节 */ }  // 定义
```
## 签名式(signature)
**参数和返回类型**,numDigits函数签名是std::size_t(int),即获得一个int返回size_t
## 定义式(definition)
提供声明式遗漏的细节，对对象而言就是分派地址，对函数而言就是代码本体，对于类而言就是列出成员
```cpp
int x;									//对象的定义式
std::sizetnumDigits(int number){		//函数的定义式
										//此函数返回其参数的数字个数，
	std::sizetdigitsSoFar=1;			//例如十位数返回 2，百位数返回 3.
	while((number /=10)!=0)++digitsSoFar;
	return digitsSoFar;
}
class widget{			//class 的定义式
    public :
    Widget();
    ~Widget();
};
template<typename T>   //template 的定义式
class GraphNode{
    public:
    GraphNode();
    ~GraphNode ();
};
```
## 初始化(initialization)
- 初始化指的是为对象赋予初始值的过程。在C++中，构造函数用于对用户自定义类型的对象进行初始化。构造函数可以有多个版本，根据需要为对象设置初值。
```cpp
class MyClass {
public:
    MyClass() {  // 默认构造函数
        // 初始化代码
    }
    MyClass(int x) {  // 带参构造函数
        // 初始化代码
    }
};
```
- **默认构造函数（Default Constructor）**
默认构造函数是一个不带任何参数的构造函数，它在你没有提供参数的情况下被调用。默认构造函数可以没有参数，或者所有参数都有默认值。
```cpp
class MyClass {
public:
    MyClass() {   // 默认构造函数
        // 初始化代码
    }
};
```
在这段代码中，MyClass()就是一个默认构造函数，它不接受任何参数。
- **explicit关键字**
explicit 关键字用于构造函数，以禁止编译器进行隐式类型转换。默认情况下，C++会在某些情况下自动调用构造函数来进行类型转换。例如，以下代码中，MyClass的构造函数可以隐式地将int类型转换为MyClass对象：
```cpp
class MyClass {
public:
    MyClass(int x) {
        // 初始化代码
    }
};

void func(MyClass obj) {
    // 处理obj
}

int main() {
    func(5);  // 这里会调用 MyClass(int) 构造函数
}
```
此段代码会由于main()中对func()的调用，将5转换为MyClass格式，这中就是隐式转换，加入explicit后可避免这种隐式转换
```cpp
class MyClass {
public:
    explicit MyClass(int x) {  // 禁止隐式转换
        // 初始化代码
    }
};
int main() {
    func(MyClass(5));  // 正确
}
```
**explicit的意义**:除非你有充分的理由允许构造函数进行隐式类型转换，否则最好将构造函数声明为explicit，这样可以避免编译器自动进行一些不被期望的转换，从而减少潜在的错误。

### 1. 拷贝构造函数（Copy Constructor）

拷贝构造函数是**用于初始化一个新对象**的。当你通过**另一个对象**来初始化一个新对象时，会调用拷贝构造函数。

**举个例子**：
```cpp
class Widget {
public:
    Widget(const Widget& other) {
        // 复制other对象的数据到当前对象
    }
};

Widget w1;    // 创建一个Widget对象
Widget w2 = w1;  // 用w1来初始化w2，调用拷贝构造函数
```

在上面的代码中，`w2`是通过`w1`来初始化的。**拷贝构造函数**会将`w1`的内容复制到`w2`。

### 2. 拷贝赋值操作符（Copy Assignment Operator）

拷贝赋值操作符是**用来给已存在的对象赋值**的。当你已经有一个对象了，并且把另一个对象的值赋给它时，调用的是拷贝赋值操作符。

**举个例子**：
```cpp
class Widget {
public:
    Widget& operator=(const Widget& other) {
        // 复制other对象的数据到当前对象
        return *this;  // 返回当前对象
    }
};

Widget w1;   // 创建一个Widget对象
Widget w2;   // 创建另一个Widget对象
w1 = w2;     // 用w2的值赋给w1，调用拷贝赋值操作符
```

这里，`w1`已经是一个对象了，然后你把`w2`的值赋给它。**拷贝赋值操作符**会将`w2`的内容复制到`w1`。

### 3. 拷贝构造函数与拷贝赋值操作符的区别

- **拷贝构造函数**：在创建**新对象**时使用。
  - 例如：`Widget w2 = w1;`
  - 这里`w2`是一个新对象，它是通过`w1`来初始化的。

- **拷贝赋值操作符**：在**已有对象赋值**时使用。
  - 例如：`w1 = w2;`
  - 这里`w1`已经存在了，你将`w2`的值赋给它。

### 4.为什么拷贝构造函数重要？

**值传递**是指你将一个对象作为参数传递给一个函数。C++会创建这个对象的副本，并调用拷贝构造函数来复制数据。

**举个例子**：
```cpp
bool hasAcceptableQuality(Widget w);  // 这里w是值传递
Widget w1;
hasAcceptableQuality(w1);  // w1会被拷贝到w中，调用拷贝构造函数
```

在这里，`w1`被**拷贝到**`w`，因为`w`是通过**值传递**的，这就会调用拷贝构造函数。这样做的缺点是，会产生一个额外的对象副本，可能会降低程序效率，尤其是当对象比较大时。


### 5. 总结

- **拷贝构造函数**：用来初始化一个新对象，通常在你用一个对象来初始化另一个对象时调用。
- **拷贝赋值操作符**：用来给一个已存在的对象赋值，通常在你用一个对象的值赋给另一个对象时调用。
- **拷贝构造函数和拷贝赋值操作符**的最大区别是，**拷贝构造函数**用来创建**新对象**，而**拷贝赋值操作符**用来为**已有对象赋值**。
- 在传递参数时，使用**引用传递**（特别是常量引用）通常是更高效的做法，因为它避免了不必要的对象拷贝。


## STL(Standard Template Library)标准模板库
### 1. 容器（Containers）
容器是用于存储数据的类。它们提供了多种方式来组织和操作数据，比如：
- **`vector`**：动态数组，大小可以自动扩展。
- **`list`**：双向链表。
- **`set`**：集合，自动排序且不允许重复。
- **`map`**：键值对集合，每个元素都有一个关联的键值。

这些容器是STL中的核心部分，提供了高效的数据存储和访问方法。

### 2. 迭代器（Iterators）
迭代器是遍历容器中元素的对象，类似于指针。STL的迭代器通过重载了`operator*`和`operator++`等操作符，使得它们可以像指针一样使用。你可以使用迭代器遍历容器中的元素，而不需要关心容器的底层实现。常见的迭代器包括：
- **`vector<int>::iterator`**：`vector<int>`类型的迭代器。
- **`set<string>::iterator`**：`set<string>`类型的迭代器。

### 3. 算法（Algorithms）
STL还提供了一组常用的算法，如：
- **`find`**：查找元素。
- **`sort`**：对容器中的元素排序。
- **`for_each`**：对容器中的每个元素应用一个函数。
这些算法可以与STL容器配合使用，简化了许多常见操作的代码。

### 4. 函数对象（Function Objects）
函数对象是实现某些功能的对象，行为类似于函数。通过重载`operator()`，这些类可以像函数一样被调用。这是STL的一个非常重要的概念，因为许多STL算法（如排序）可以接收函数对象作为参数，用来指定自定义的行为。

## 命名习惯(Naming Conventions)
- 就是缩写
## 关于线程（Threading Consideration）

### 1. **C++对线程的支持**
- **C++和线程的关系**：C++语言本身并不关注线程和并发（concurrency）。早期的C++标准（特别是C++98标准）在语言本身并没有提供对多线程编程的支持。多线程编程在C++语言中并不是“内建”的概念。
- **C++标准库的不足**：C++标准库最初也没有包含对多线程的支持。在C++98标准发布时，多线程编程还不像现在这样普及，因此标准库并未涉及这方面的内容。

### 2. **多线程编程的出现**
- **多线程编程的普及**：随着计算机硬件的进步，尤其是多核处理器的普及，多线程编程变得越来越重要。现代的C++标准（如C++11及以后）才开始正式引入对多线程的支持。
- **C++标准库和多线程的差距**：尽管C++现在支持多线程，但书中的作者承认，标准C++并没有内建的强大多线程支持。也就是说，C++标准库并没有完全涵盖多线程编程的所有需求，尤其是在“线程安全性”（thread safety）方面的挑战。

### 3. **线程安全性**
- **线程安全问题**：作者提到“线程安全性”是多线程编程中的重要话题，它涉及到多个线程访问共享资源时如何避免数据冲突或不一致。例如，当多个线程同时访问或修改同一块内存区域时，如何保证不会出现竞态条件（race condition）或其他并发错误。
- **书中的处理方式**：尽管本书的焦点主要是在**标准C++**上，且大部分内容假设是单线程的，但作者也提到，他会在可能引发线程安全问题的地方指出。也就是说，如果在某个标准C++构件中，可能会在多线程环境中引发问题，作者会专门提醒读者。

### 4. **针对线程的讨论**
- **针对多线程开发者的建议**：如果你是多线程编程的新手或不需要关心线程问题，可以忽略本书中与线程相关的讨论。但是如果你正在编写与线程相关的应用程序或库，作者建议你特别注意这些提示，因为它们可能影响到多线程环境中的行为。
- **与线程安全相关的细节**：作者强调，虽然本书的内容主要基于单线程的C++编程，但他会在讨论中加入更多关于多线程的提醒，尤其是关于“线程安全”的部分，帮助程序员避免常见的并发问题。

## TR1和Boost
这段话讨论了**TR1**和**Boost**，这两者是C++中非常重要的扩展库。让我帮你进一步解析这段内容：

### 1. **TR1（Technical Report 1）**
- **什么是TR1**：TR1（技术报告1）是C++标准委员会发布的一份技术报告，描述了将一些新功能引入C++标准库的提案。TR1是C++标准库扩展的一部分，目标是增强标准库的功能和灵活性。它包含了一些新的类模板和函数模板，主要涉及以下几个方面：
  - **哈希表（hash tables）**：一种数据结构，用于通过键值对存储数据，能够在常数时间内查找元素。
  - **引用计数智能指针（reference-counting smart pointers）**：智能指针可以自动管理动态分配内存的生命周期，引用计数智能指针会在没有任何引用时自动删除对象。
  - **正则表达式（regular expressions）**：用于匹配文本模式的工具，可以用来进行复杂的字符串搜索和替换。
  - **其他功能**：TR1还包含了其他一些新的功能，用来解决C++中现有标准库的一些缺陷和不足。
  
- **TR1的命名空间**：TR1中的所有组件都被放置在一个命名空间`tr1`内，而`tr1`又嵌套在标准库的`std`命名空间中。举个例子，如果你想使用TR1中的哈希表，你可能需要使用类似`std::tr1::unordered_map`这样的名称。

### 2. **Boost库**
- **Boost简介**：Boost是一个C++的开源库，包含了大量高质量、跨平台的库，扩展了C++的功能。Boost库提供的功能涵盖了从容器到多线程、正则表达式、智能指针、数学运算等各个领域。Boost库中的很多功能后来被纳入了C++标准库中，比如智能指针、`shared_ptr`等。
  
- **与C++标准库的关系**：Boost通常被视为C++标准库的“试验场”，许多新特性或改进首先在Boost中出现，经过广泛的使用和验证后，再考虑是否加入到C++标准库。因此，很多Boost中的功能与C++标准库密切相关。

### 3. **TR1和Boost的引入背景**
- **为什么要提到TR1和Boost**：书中提到TR1和Boost，是因为它们提供了大量扩展C++标准库功能的工具和类，这对于提升程序的效率、可读性和可维护性非常有帮助。作者希望通过这两个库来弥补C++标准库的一些不足，尤其是在一些高级功能（比如哈希表、正则表达式和智能指针等）上。

- **位置和顺序**：这段话还提到，关于TR1和Boost的详细讨论被放在了本书的后面（条款54和条款55），因为从结构上来说，这样的安排更合理，尽管读者可以选择提前阅读这些部分，但如果按照书中的顺序继续阅读并不妨碍理解。

